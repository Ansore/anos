 

# 获取物理内存信息

之前再Loader阶段通过BIOS中断服务程序`int 0x15; ax=0xe820`，包保存到物理地址`0x7e00`。此处存储的物理地址空间信息存有若干组，描述计算机平台的地址空间划分情况，数据量回根据当前主板硬件配置和物理内存容量而定，每条物理地址空间信息占用`20B`，详细定义如下：

```c
struct Memory_E820_Formate {
  unsigned int address1;
  unsigned int address2;
  unsigned int length1;
  unsigned int length2;
  unsigned int type;
};
```

该结构体格式化物理地址`0x7e00`处的数据。还必须经过页表映射后才能使用，转换后的线性地址是`0xffff800000007e00`。

显示内存信息：

```c
void memory_init() {
  int i, j;
  unsigned long total_memory;
  struct Memory_E820_Formate *p = NULL;

  p = (struct Memory_E820_Formate *)0xffff800000007e00;
  for (i = 0; i < 32; i++) {
    color_printk(ORANGE, BLACK,
                 "Adress:%#010x, %08x\tLength:%#010x,%08x\tType:%010x\n",
                 p->address2, p->address1, p->length2, p->length1, p->type);
    unsigned long tmp = 0;
    if (p->type == 1) {
      tmp = p->length2;
      total_memory += p->length1;
      total_memory += tmp << 32;
    }

    p++;
    if (p->type > 4) {
      break;
    }
  }
  color_printk(ORANGE, BLACK, "OS can used total ram: %018lx\n", total_memory);
}
```

将指针变量p指向线性地址`0xffff800000007e00`处，通过32次循环逐条显示地址空间的分布信息。其`type`值不会大于4，如果出现了大于4的情况，则是程序程序出现了脏数据，就跳出循环。

显示结果如下：

![Screenshot_20220730_180936](https://img.ansore.top/2022/07/30/57552b7a1279ca7363ecfa0f972fbd00.png)

可以看出可用的物理内存空间（type=1）由两部分组成，一部分是容量为`0x9f00`的段，另一部分是容量为`0x7fef0000`的段，可以计算处可用的物理总内存容量为`0x9f000+0x7fef0000=7ff8f000 B`大约是`2047.55MB`。与Bochs的内存设置一致：

```
memory: host=2048M, guest=2048M
```

# 计算可用物理内存页数

可用物理地址页数通常间接描述了操作系统可以使用的物理内存数，这些页必须按照页大小进行物理地址对齐。

```c
// 8 bytes per cell
#define PTRS_PER_PAGE 512

#define PAGE_OFFSET ((unsigned long)0xffff800000000000)

#define PAGE_GDT_SHIFT 39
#define PAGE_1G_SHIFT 30
#define PAGE_2M_SHIFT 21
#define PAGE_4K_SHIFT 12

#define PAGE_2M_SIZE (1UL << PAGE_2M_SHIFT)
#define PAGE_4K_SIZE (1UL << PAGE_4K_SHIFT)

#define PAGE_2M_MASK (~(PAGE_2M_SIZE - 1))
#define PAGE_4K_MASK (~(PAGE_4K_SIZE - 1))

#define PAGE_2M_ALIGN(addr)                                                    \
  (((unsigned long)(addr) + PAGE_2M_SIZE - 1) & PAGE_2M_MASK)
#define PAGE_4K_ALIGN(addr)                                                    \
  (((unsigned long)(addr) + PAGE_4K_SIZE - 1) & PAGE_4K_MASK)

#define VIRT_TO_PHY(addr) ((unsigned long)(addr)-PAGE_OFFSET)
#define PHY_TO_VIRT(addr)                                                      \
  ((unsigned long *)((unsigned long)(addr) + PAGE_OFFSET))
```

`PTRS_PER_PAGE`代表页表项个数，在64位模式下每个页表项占用字节数由原来的4个字节扩展为8个字节，每个页表大小为4KB，因此页表项个数为4KB/8B=512。

`PAGE_OFFSET`代表内核的起始线性地址，该地址位于物理地址0处。

`PAGE_4K_SHIFT`代表$2^{PAGE\_4K\_SHIFT}$B=4KB，同理$2^{PAGE\_2M\_SHIFT}$B=2MB、$2^{PAGE\_1G\_SHIFT}$B=1GB，以此类推，它们将64位模式下的每种页表项代表的物理页容量都表示出来。

`PAGE_2M_SIZE`代表2MB页的容量，展开后将1向左移动`PAGE_2M_SHIFT`位。

`PAGE_2M_MASK`是2MB数值的屏蔽码，通常用于屏蔽低于2MB的数值。

`PAGE_2M_ALIGN(addr)`的作用是将参数addr按2MB页的上边界对齐。

`VIRT_TO_PHY(addr)`用于将内核层虚拟地址转换成物理地址。`PHY_TO_VIRT(addr)`的功能恰好相反。

定义全局结构体`struct global_memory_descriptor`用来保存有关内存信息：

```c
struct E820 {
  unsigned long address;
  unsigned long length;
  unsigned int type;
} __attribute__((packed));

struct global_memory_descriptor {
  struct E820 e820[32];
  unsigned long e820_length;
};

extern struct global_memory_descriptor memory_management_struct;
```

`__attribute__((packed))`修饰该结构体不会对齐空间，改用紧凑格式，这样才能解析内存空间的分布信息。

全局变量初始化：

```c
struct global_memory_descriptor memory_management_struct = {{0}, 0};
```

获取内存信息：

```c
  p = (struct E820 *)0xffff800000007e00;
  for (i = 0; i < 32; i++) {
    color_printk(ORANGE, BLACK,
                 "Address:%#018lx\tLength:%#018lx\tType:%#010x\n", p->address,
                 p->length, p->type);
    if (p->type == 1) {
      total_memory += p->length;
    }

    memory_management_struct.e820[i].address += p->address;
    memory_management_struct.e820[i].length += p->length;
    memory_management_struct.e820[i].type += p->type;
    memory_management_struct.e820_length = i;

    p++;
    if (p->type > 4) {
      break;
    }
  }
  color_printk(ORANGE, BLACK, "OS can used total ram: %018lx\n", total_memory);
```

将内存信息都保存到全局变量`memory_management_struct`。

然后对`E820`结构体数组中可用的内存段进行2MB物理页边界对齐，并统计出可用物理页的总量：

```c
  total_memory = 0;
  for (i = 0; i <= memory_management_struct.e820_length; i++) {
    unsigned long start, end;
    if (memory_management_struct.e820[i].type != 1) {
      continue;
    }
    start = PAGE_2M_ALIGN(memory_management_struct.e820[i].address);
    end = ((memory_management_struct.e820[i].address +
            memory_management_struct.e820[i].length) >>
           PAGE_2M_SHIFT)
          << PAGE_2M_SHIFT;
    if (end <= start) {
      continue;
    }
    total_memory += (end - start) >> PAGE_2M_SHIFT;
  }

  color_printk(ORANGE, BLACK, "OS can used total 2M PAGEs: %#010x=%010d\n",
               total_memory, total_memory);
```

使用宏函数`PAGE_2M_ALIGN`将这些段的结束地址按2MB页的上边界对齐，经过对齐处理后的地址才是段的有效内存起始地址。这些段结束地址是由段的起始地址和段长度相加，随后将计算结果用移位的方式按2MB页的下边界对齐，也可以使用之前定义的宏常量`PAGE_2M_MASK`进行页的下边界对齐操作。如果计算后的起始地址小于等于计算后的结束地址，则视这个段为有效内存段，进而计算可用的物理页数量，并在屏幕上打印可用的物理页总数量。

虚拟机可用内存页数量为1022，运行结果如下：

![Screenshot_20220730_225903](https://img.ansore.top/2022/07/30/3ffb2df992b5e9dc96934bff6ac3d036.png)

# 分配可用的物理内存页

## 物理页管理结构的定义和初始化

为了汇总可用物理内存信息并方便以后管理，现在特将整个内存空间（通过`E820`功能返回的各个内存段信息，包括RAM空间、ROM空间、保留空间等），按`2MB`大小的物理内存页进行分割和对齐。分割后的每个物理内存页由一个`struct page`结构体负责管理，然后使用区域空间结构体`struct zone`代表各个可用物理内存区域（可用物理内存段），并记录和管理本区域物理内存页的分配情况。最后将`struct page`结构体和`struct zone`结构体都保存到全局结构体`struct global_memory_descriptor`内。

物理内存页的管理结构示意图：

![Screenshot_20220730_231227](https://img.ansore.top/2022/07/30/88f511487f511185bbd77d5910a6d1ec.png)

`pages_struct`结构包含所有内存结构体，`zones_struct`结构包含所有区域空间结构体，它们增强全局结构体`struct global_memory_descriptor`的管理能力。每当执行页的分配或回收等操作时，内核回从全局结构体`struct global_memory_descriptor`中索引处对应的区域空间结构和页结构，并调整区域空间结构的管理信息与页结构的属性和参数。

内存页结构、区域空间结构和全局结构体详细定义：

```c
struct page {
  struct zone *zone_struct;
  unsigned long phy_address;
  unsigned long attribute;
  unsigned long reference_count;
  unsigned long age;
};
```

- `zone_struct`：指向本页所属的区域结构体
- `phy_address`：页的物理地址
- `attribute`：页的属性，描述当前页的映射状态、活动状态、使用者等信息
- `reference_count`：描述该页的引用次数
- `age`：描述页的创建时间

`phy_address`和`zone_struct`结构成员可以通过计算获得，添加这两个成员是为了节省计算时间，以空间换时间。

```c
struct zone {
  struct page *pages_group;
  unsigned long pages_length;
  unsigned long zone_start_address;
  unsigned long zone_end_address;
  unsigned long zone_length;
  unsigned long attribute;

  struct global_memory_descriptor *gmd_struct;

  unsigned long page_using_count;
  unsigned long page_free_count;
  unsigned long total_pages_link;
};
```

- `pages_group`：`struct page`结构体数组指针
- `pages_length`：本区域包含的`struct page`结构体数量
- `zone_start_address`：本区域的起始页对齐地址
- `zone_end_address`：本区域的结束页对齐地址
- `zone_length`：本区域经过对齐后的地址长度
- `attribute`：本区域空间的属性
- `gdm_struct`：指向全局结构体`struct global_memory_descriptor`
- `page_using_count`：本区域已经使用的物理内存页数量
- `page_free_count`：本区域空闲物理内存页数量
- `total_pages_link`：本区域物理页被引用次数

一个物理页可以同时映射到线性地址空间的多个位置上，所有`total_pages_link`与`page_using_count`在数值上不一定相等。而成员变量`attribute`则用于描述当前区域是否支持DMA、页是否经过页表映射等信息。

```c
struct global_memory_descriptor {
  struct E820 e820[32];
  unsigned long e820_length;

  unsigned long *bits_map;
  unsigned long bits_size;
  unsigned long bits_length;

  struct page *pages_strust;
  unsigned long pages_size;
  unsigned long pages_length;

  struct zone *zones_struct;
  unsigned long zones_size;
  unsigned long zones_length;

  unsigned long start_code, end_code, end_data, end_brk;

  unsigned long end_of_struct;
};
```

- `e820[32]`：物理内存段结构数组
- `e820_length`：物理内存段结构数组长度
- `bits_map`：物理地址空间页映射位图
- `bits_size`：物理地址空间页数量
- `bits_length`：物理地址空间页数量
- `pages_struct`：指向全局`struct page`结构体数组的指针
- `pages_size`：`struct page`结构体总数
- `pages_length`：`struct page`结构体数组长度
- `zones_struct`：指向全局`struct zone`结构体数组的指针

- `zones_size`：`struct zone`结构体总数
- `zones_length`：`struct zone`结构体数组长度
- `start_code`：内核程序的起始代码段地址
- `end_code`：内核程序的结束地址段地址
- `end_data`：内核程序的结束数据段地址
- `end_brk`：内核程序的结束地址
- `end_of_struct`：内存页管理结构的结尾地址

`bits_*`相关字段是`struct page`结构体的位图映射，它们一一对应的关系。建立`bits`位图映射的目的是为方便检索`pages_struct`中的空闲页表，而`pages_*`和`zones_*`相关变量用来记录`struct page`和`struct zone`结构体数组的首地址以及资源分配情况的信息。
