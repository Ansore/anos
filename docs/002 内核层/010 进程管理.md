# 进程管理模块

进程是拥有执行资源的最小单位，它为每个程序维护着运行时的各种资源，如进程ID、进程的页表、进程执行现场的寄存器值、进程各个段地址空间分布信息以及进程执行时的维护信息等，它们在程序的运行期间会被经常或实时更新。这些资源被结构化到PCB（Process Control Block，进程控制结构体）内，PCB作为进程调度的决策信息供调度算法使用。

进程调度策略负责将满足运行条件或迫切需要执行的进程到空闲处理器中执行。进程调度策略直接影响程序的执行效率。

# PCB

PCB用于记录进程的资源使用情况（包括软件资源是硬件资源）和运行状态等。

```c
struct task_struct {
  struct list list;
  volatile long state;
  unsigned long flags;

  struct mm_struct *mm;
  struct thread_struct *thread;

  // 0x0000000000000000 - 0x00007fffffffffff user
  // 0xffff800000000000 - 0xffffffffffffffff kernel
  unsigned long addr_limit;

  long pid;
  long counter;
  long signal;
  long priority;
};
```

成员变量`mm`与`thread`负责在进程调度过程中保存或还原CR3控制寄存器的页目录基地址和通用寄存器值

![Screenshot_20220821_194848](https://img.ansore.top/2022/08/21/503a1dfccdacfdabeca5188357a0da4e.png)

`state`成员变量使用`volatile`关键字修饰，说明该变量可能会在意想不到的情况下修改，因此编译器不要对此成员变量进行优化。处理器每次使用这个变量前，必须重新读取该变量的值，而不能使用保存在寄存器的值。

内存空间分布结构体`struct mm_struct`描述了进程的页表结构和各程序段信息，其中有页目录基地址、代码段、数据段、只读数据段、应用层栈顶地址等信息。

```c
struct mm_struct {
  pml4t_t *pgd; // page table point
  unsigned long start_code, end_code;
  unsigned long start_data, end_data;
  unsigned long start_rodata, end_rodata;
  unsigned long start_brk, end_brk;
  unsigned long start_stack;
};
```

`mm_struct`结构体各个成员变量的功能说明，其中成员变量`pgd`保存在`CR3`控制寄存器值（页目录基地址与页表属性的组合值），成员变量`start_stack`记录应用程序在应用层的栈顶地址，其他成员变量描述了应用程序的各段地址空间。![Screenshot_20220821_195640](https://img.ansore.top/2022/08/21/57dcd2f5cc3fc188187f2f54b6fb3c2e.png)

![Screenshot_20220821_195707](https://img.ansore.top/2022/08/21/8bca385335deadb4702f7681bface903.png)

每当进程发生调度切换时，都必须将执行现场的寄存器保存起来，已备再次执行时使用。

这些数据都保存在`struct thread_struct`结构体内：

```c
struct thread_struct {
  unsigned long rsp0; // in tss
  unsigned long rip;
  unsigned long rsp;
  unsigned long fs;
  unsigned long gs;
  unsigned long cr2;
  unsigned long trap_nr;
  unsigned long error_code;
};
```

其中成员变量`rsp0`记录应用程序在内核层使用的栈基地址，`rsp`保存这进程切换时的栈指针值，`rip`成员保存着进程切换回来时执行代码的地址。

![Screenshot_20220821_200012](https://img.ansore.top/2022/08/21/cace5d8741f2e7588d034feed71403fe.png)

关于进程的内核层栈空间实现，借鉴Linux内核设计思想，把进程控制结构体`struct task_struct`与进程的内核层栈空间融为一体。其中，低地址处存放`struct task_struct`结构体，余下高地址空间作为进程内核层栈空间使用，如下：

![Screenshot_20220821_200307](https://img.ansore.top/2022/08/21/ae370888ce62f58d82e510ec79fa0e46.png)

```c
union task_union {
  struct task_struct task;
  unsigned long stack[STACK_SIZE / sizeof(unsigned long)];
} __attribute__((aligned(8))); // 8 bytes align
```

借助联合体，把进程控制结构体`struct task_struct`与进程的内核层栈空间连续到了一起，其中宏常量`TASK_SIZE`被定义为32768B（32KB），它表示进程的内核栈空间和`struct task_struct`结构体占用的存储空间总量为32KB，在Intel i386处理器架构的Linux内核中默认使用8KB的内核栈空间。由于64位处理器的寄存器位宽扩大一倍，相应的栈空间也必须扩大，此处暂时设定为32KB，待到存储空间不足再扩容

这个联合体占用32KB，并将这段空间按8B进行对齐，实际上这个联合体的起始地址必须按照32KB进行对齐。
